###**模块化方案**
- 在线编译模块方案
	1. AMD - RequireJS
	2. CMD - SeaJS
- 预编译模块方案
	1. browserify
	2. webpack

在线编译模块，是将模块化的定义代码放在了项目的代码中，代码中需要使用特定的方式（并非更为简单易懂的CommonJS方式）去定义和使用模块，浏览器在运行代码的时候会进行模块的依赖分析。

预编译模块方案，在预编译时进行模块化的处理，即在预编译的时候就进行模块的依赖分析，生成可在浏览器中运行的代码，浏览器运行期间无需做额外操作。

**预编译模块方案更为智能，这里选用预编译模块方案**

browserify - 小而灵活，小工具协作的方式，需要某个功能就去找相关的 browserify 插件，使用配置文件或整合到其他第三方构建工具的脚本中，上手一般

webpack - 大而全，整体解决方案，基于配置文件的方式，上手容易

browserify 近年来更新速度较慢，而 webpack 社区较为活跃，目前已成为为主流

**这里选用 webpack 作为预编译模块方案**
**风险：大而全工具的通病，为了简化用户使用，屏蔽了实现细节，出现问题需要自行跟源码解决**

###**前端构建工具**
1. Grunt - 需要编写构建脚本，有自己的脚本规范。通过在脚本中配置任务来定义构建流程
2. Gulp - 需要编写构建脚本，有自己的脚本规范。在 Grunt 的基础上进行了精简和优化，让用户可以使用 IO 流的方式进行构建脚本的编写，提高了构建速度，简化了脚本的复杂度。
3. npm script - npm 自带，基于命令行，上手容易，不依赖于其他三方构建工具
**没有必要使用三方的构建工具，如 Grunt、Gulp等，在项目和实际使用的工具（如uglifyjs，cssmin）之间再加入构建工具这一层，无疑会增加学习和维护成本，这里选用 npm script 作为前端构建工具**

###**项目实现方案**
####**状态管理层+视图层+UI库/UI组件库**
**状态管理层**
1. VallinaJS（即原生JS） 实现 SAM（即 State-Action-Model） 设计模式
从零开始实现，优点是灵活可控，缺点开发周期长
2. Flux
facebook开发的一款用于项目内组件状态管理的框架，配合react使用，成为完整的解决方案。本人没有使用过，不过看业界口碑，目前已被 redux 取代。
3. Redux
Flux 的替代品，更好的实现方案和设计思想使它成为目前和 React 搭配使用的主流。优点是开发周期短，缺点是依赖框架，遇到问题可能需要跟源码。
4. Vuex
Vue.js 自带的状态管理框架，对 Vue.js 支持较好

**视图层**
1. React
成长较快，社区最大，有多种UI库支持
2. Vue.js
成长较快，社区一般，虽比不上React，但国内有不上公司使用，UI库支持方面较为欠缺
3. InfernoJS
成长较快，据作者所述，此为 React 的精简版，速度比 React 更快，但是如果需要兼容 React 上的 UI 库，需要使用该库提供的方案 inferno-compact 工具
4、VallinaJS（原生JS）直接拼接 HTML

**UI库**
1. Ant Design（https://ant.design/index-cn） - 蚂蚁金服提供一套 React UI 组件库
优点是有中文支持，缺点是使用别人的 UI 库，设计方面要遵循别人的准则（见官网），设计会被局限。
官网上介绍这套组件库支持其他的视图层框架，如 vue.js。
2、Elemental UI（http://elemental-ui.com/） - React UI 组件库，设计风格中规中矩，和 bootstrap 类似。
3、Material-UI（http://www.material-ui.com/） - React UI 组件库，设计风格比较炫。
4、Bootstrap（http://getbootstrap.com/） - 原生 UI 库，优点是原生，可控可扩展性强；缺点是一些交互需要自己编写，增加开发量，而且感觉设计风格也比较老了（不过也有对应的 React UI 组件库）。
5、Semantic-ui（http://semantic-ui.com/） - 原生 UI 库，相比于Bootstrap 的 css命名混乱，Semantic-ui 提供了更友好的定义方式，同时也感觉设计风格比 Bootstrap 更胜一筹

####**细节补充**



