/**
 * 数据源模块
 */
import React from 'react';
import PropTypes from 'prop-types';

import * as moment from 'moment';
import ReactEcharts from 'echarts-for-react';
import { Checkbox } from 'office-ui-fabric-react/lib/Checkbox';
import { connect } from 'react-redux';

import Tree from '../../../components/Tree';
import Table from '../../../components/Table';
import Confirm from '../../../components/Confirm';
import ObjectId from '../../../common/objectId.js';
import HistoryChartConfig from '../HistoryChartConfigModal';
import { getTagDict } from '../../../redux/epics/home.js';
import CustomSpinner from '../../../components/CustomSpinner';

import ParametricExampleModal from './ParametricExampleModal.js';
import { tagMatch } from '../../../common/utils';
import s from './DataSourcePanel.css';
const css = (className1, className2 = '') => {
  return className1
    .split(' ')
    .map(v => s[v])
    .concat(className2.split(' '))
    .join(' ')
    .trim();
};
const isCommonObj = (o1 = {}, o2 = {}) => {
  let rs = true;
  let keys1 = Object.keys(o1),
    keys2 = Object.keys(o2);
  if (
    keys1.length != keys2.length ||
    keys1.filter(v => keys2.indexOf(v) < 0).length > 0
  ) {
    return false;
  }
  keys1.forEach(k => {
    if (o1[k] != o2[k]) {
      rs = false;
    }
  });
  return rs;
};
class RenameText extends React.PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      isShowInput: false
    };
    this._removeItem = this._removeItem.bind(this);
    this._renameItem = this._renameItem.bind(this);
    this._onTextBlur = this._onTextBlur.bind(this);
    this._onTextKeyDown = this._onTextKeyDown.bind(this);
    this._onTextClick = this._onTextClick.bind(this);
  }
  componentDidMount() {
    const { defaultShowInput = false } = this.props;
    this.setState({
      isShowInput: defaultShowInput
    });
  }
  componentDidUpdate() {
    const { isShowInput } = this.state;
    const { data } = this.props;
    if (isShowInput) {
      this.refs.input.focus();
      this.refs.input.value = data.name;
      this.refs.input.select();
    }
  }
  render() {
    const { dom = [], data } = this.props;
    const { isShowInput } = this.state;
    return isShowInput ? (
      <div className={css('RenameText')}>
        <input
          ref="input"
          className={css('text')}
          onBlur={this._onTextBlur}
          onKeyDown={this._onTextKeyDown}
          onClick={this._onTextClick}
        />
      </div>
    ) : (
      <div className={css('RenameText')}>
        {dom}
        <div className={css('toolbar')}>
          <button title="重命名" onClick={this._renameItem}>
            <i className={'ms-Icon ms-Icon--Rename'} />
          </button>
          <button title="删除">
            <i
              className={'ms-Icon ms-Icon--Delete'}
              onClick={this._removeItem}
            />
          </button>
        </div>
      </div>
    );
  }
  _removeItem(e) {
    e.preventDefault();
    e.stopPropagation();
    const { data, removeItem = () => {} } = this.props;
    removeItem(data.id);
  }
  _renameItem(e) {
    e.preventDefault();
    e.stopPropagation();
    this.setState({
      isShowInput: true
    });
  }
  _onTextBlur() {
    const { data, renameItem = () => {} } = this.props;
    renameItem(data.id, this.refs.input.value);
    this.setState({
      isShowInput: false
    });
  }
  _onTextKeyDown(e) {
    if (e.key == 'Enter') {
      this._onTextBlur();
    }
  }
  _onTextClick(e) {
    e.preventDefault();
    e.stopPropagation();
  }
}
class DataSourcePanel extends React.PureComponent {
  static isNeedWranWrapSpinner = false;
  constructor(props) {
    super(props);
    this.getDsItemsAsync = undefined;
    this.getDsValuesAsync = undefined;
    this.getDsHistoryAsync = undefined;
    this.dsMap = new Map(); //缓存
    this.state = {
      dataSource: [],
      spinner: false,
      chartSpinner: false,
      treeSpinner: false,
      treeSpinnerLabel: '0.0%',
      selectedColumns: [],
      historyData: {
        list: [],
        timeShaft: []
      },
      showAddItem: false
    };
    this._onGroupSelect = this._onGroupSelect.bind(this);
    this._onAddGroupBtn = this._onAddGroupBtn.bind(this);
    this._addGroup = this._addGroup.bind(this);
    this._removeGroup = this._removeGroup.bind(this);
    this._renameGroup = this._renameGroup.bind(this);
    this._onInputDrop = this._onInputDrop.bind(this);
    this._onInputBlur = this._onInputBlur.bind(this);
    this._onInputFocus = this._onInputFocus.bind(this);
    this._onInputKeyDown = this._onInputKeyDown.bind(this);
    this._onColumnSelected = this._onColumnSelected.bind(this);
    this._setChartCondition = this._setChartCondition.bind(this);
    this._showModal = this._showModal.bind(this);
    this._showChartConfig = this._showChartConfig.bind(this);
    this._onCheckboxChang = this._onCheckboxChang.bind(this);
    this._updateData = this._updateData.bind(this);
    this._onTreeDrop = this._onTreeDrop.bind(this);
    this._onTabelDrop = this._onTabelDrop.bind(this);
  }
  componentDidMount() {
    this.componentWillReceiveProps(this.props);
  }
  componentWillReceiveProps(nextProps) {
    const { data, tagDict, getTagDict, updateModule } = nextProps;
    let activedGroup = data.options.activedGroup;
    if (
      !activedGroup ||
      data.options.groups.find(v => v._id == data.options.activedGroup) ==
        undefined
    ) {
      activedGroup = data.options.groups[0]._id;
      updateModule(data.setIn(['options', 'activedGroup'], activedGroup));
    } else {
      if (activedGroup != this.props.data.options.activedGroup) {
        //切换配置
        this.dsMap = new Map();
      }
      this._getDsItems(nextProps);
    }

    if (tagDict.length == 0) {
      getTagDict();
    }
    if (!data.options.timeConfig || !data.options.timeConfig.timeStart) {
      let now = +new Date(),
        yestady = now - 24 * 60 * 60 * 1000;
      let timeEnd = moment.default(now).format('YYYY-MM-DD HH:mm:00'),
        timeStart = moment.default(yestady).format('YYYY-MM-DD HH:mm:00');
      this._setChartCondition({
        timeStart,
        timeEnd,
        timeFormat: 'h1'
      });
    }
  }
  componentWillUpdate(nextProps, nextState) {
    const { data } = this.props;
    // const activedGroup = data.options.activedGroup,
    //   nextActivedGroup = nextProps.data.options.activedGroup;
    // if (nextActivedGroup != undefined && activedGroup != nextActivedGroup) {
    //   //切换配置
    //   this.dsMap = new Map();
    //   this._getDsItems(nextProps);
    // }
    if (
      (nextState.selectedColumns[0] != undefined &&
        nextState.selectedColumns[0] != this.state.selectedColumns[0]) ||
      !isCommonObj(nextProps.data.options.timeConfig, data.options.timeConfig)
    ) {
      this._getDsHistory(nextState, nextProps);
    }
  }
  componentDidUpdate() {
    const { data } = this.props;
    data.options.params.forEach(p => {
      let target = this.refs['Table'].refs[`input_${p.name}`];
      target.value = target.dataset.value || '';
    });
  }
  render() {
    const { data, tagDict, i18n } = this.props;
    const {
      dataSource,
      spinner,
      chartSpinner,
      treeSpinner,
      treeSpinnerLabel,
      selectedColumns,
      showAddItem
    } = this.state;
    const activedGroup = data.options.activedGroup;
    const timeConfig = data.options.timeConfig || {};
    let params = data.options.params,
      completing = data.options.completing || 0;
    //添加参数组控件
    let addItem = [];
    if (showAddItem) {
      addItem = [
        {
          id: ObjectId(),
          name: 'Default',
          parent: 0,
          isParent: 0,
          render: (dom, data, parent) => {
            return (
              <RenameText
                dom={dom}
                data={data}
                defaultShowInput={true}
                renameItem={this._addGroup}
              />
            );
          }
        }
      ];
    }
    return (
      <div className={css('dataSourceWrap clear')}>
        <div className={s['left']}>
          <div className={s['title']}>
            {i18n.MODULE_NAME}
            <div className={css('btnGroup clear')}>
              <button title={i18n.TITLE_ADD} onClick={this._onAddGroupBtn}>
                <i className={'ms-Icon ms-Icon--Add'} />
              </button>
            </div>
          </div>
          <div className={s['lt']}>
            <button onClick={this._showModal}>
              {i18n.PARAMETERS_OF_THE_SAMPLE}
            </button>
          </div>
          <div
            className={s['lm']}
            onDrop={this._onTreeDrop.bind(this)}
            onDragOver={ev => {
              ev.preventDefault();
            }}
          >
            <Tree
              selectedKeys={[activedGroup]}
              items={data.options.groups
                .map(v => ({
                  id: v._id,
                  name: v.name,
                  parent: 0,
                  isParent: 0,
                  render: (dom, data, parent) => {
                    return (
                      <RenameText
                        dom={dom}
                        data={data}
                        parent={parent}
                        removeItem={this._removeGroup}
                        renameItem={this._renameGroup}
                      />
                    );
                  }
                }))
                .concat(addItem)}
              onSelect={this._onGroupSelect}
              leafIcon={
                <i
                  className="ms-Icon ms-Icon--FabricFolder"
                  aria-hidden="true"
                />
              }
              indent={8}
              skin="whiteSkin h40"
            />
            <CustomSpinner visible={treeSpinner} label={treeSpinnerLabel}/>
          </div>
          <div className={s['lb2']}>
            <Checkbox
              label={i18n.IS_COMPLETE}
              onChange={this._onCheckboxChang}
              checked={!!completing}
            />
          </div>
          <div className={s['lb1']}>
            <HistoryChartConfig
              chartCondition={timeConfig}
              changeCondition={this._setChartCondition}
            />
          </div>
        </div>
        <div className={s['right']}>
          <div className={css('btnGroup clear')}>
            <button>
              <i className={'ms-Icon ms-Icon--ExcelDocument'} />
              <span>{i18n.IMPORT_TO_EXCEL}</span>
            </button>
            <button>
              <i className={'ms-Icon ms-Icon--ExcelDocument'} />
              <span>{i18n.EXPORT_TO_EXCEL}</span>
            </button>
            <button>
              <i className={'ms-Icon ms-Icon--DocumentManagement'} />
              <span>{i18n.BULK_MANAGE}</span>
            </button>
          </div>
          <div
            className={css('tableWrap')}
            onDrop={this._onTabelDrop.bind(this)}
            onDragOver={ev => {
              ev.preventDefault();
            }}
          >
            <Table
              ref="Table"
              columns={this._getColumns()}
              dataSource={dataSource}
              selectedKeys={selectedColumns}
              onSelect={this._onColumnSelected}
            />
            <div
              className={css('chartWrap')}
              style={{
                height: selectedColumns.length > 0 ? '40%' : '0'
              }}
            >
              <div
                className={css('configWrap')}
                style={{
                  display: 'none'
                }}
              >
                {`${timeConfig.timeStart}-${timeConfig.timeEnd}`}
                <div
                  className={css('chartConfig')}
                  onClick={this._showChartConfig}
                >
                  <i className={'ms-Icon ms-Icon--Settings'} />
                </div>
              </div>
              {this._createChart()}
              <CustomSpinner visible={chartSpinner} />
            </div>
            <CustomSpinner visible={spinner} />
          </div>
        </div>
        <ParametricExampleModal
          ref="ParametricExampleModal"
          data={params}
          tagDict={tagDict}
          updateData={this._updateData}
          i18n={i18n}
        />
      </div>
    );
  }
  _getDsItems(props) {
    if (this.getDsItemsAsync) {
      return;
    }

    const { data, updateModule } = props;
    let activedGroup = data.options.activedGroup;
    let selectedItem = data.options.groups.find(v => v._id == activedGroup),
      index = data.options.groups.findIndex(v => v._id == activedGroup),
      ids = [];
    let dataSource = [],
      params = data.options.params;
    if (selectedItem) {
      params.forEach((v, i) => {
        let item = this.dsMap.get(selectedItem.data[v.name]);
        let alias = '',
          value = '';
        if (item) {
          alias = item.alias;
          value = item.data || '';
        }
        dataSource.push({
          key: i,
          name: v.name,
          point: selectedItem.data[v.name],
          value: value,
          tag: v.tags,
          alias: alias
        });
      });
    }
    Object.keys(selectedItem.data).forEach(v => {
      if (!this.dsMap.has(selectedItem.data[v])) {
        if (selectedItem.data[v]) {
          ids.push(selectedItem.data[v]);
        }
      }
    });
    this.setState({
      dataSource
    });
    if (ids.length == 0) {
      return;
    }
    this.setState({
      spinner: true
    });
    this.getDsItemsAsync = apiFetch.getDsItemsById(ids).subscribe({
      fail: rs => {
        this.getDsItemsAsync = undefined;
        console.log(rs);
      },
      next: rs => {
        this.getDsItemsAsync = undefined;
        ids.forEach((id, i) => {
          if (rs[i] && rs[i].projId != -1) {
            this.dsMap.set(id, rs[i]);
          }
        });
        let { dataSource } = this.state;
        dataSource.forEach((v, i) => {
          let data = this.dsMap.get(v.point);
          this.refs['Table'].refs[`input_${v.name}`] &&
            this.refs['Table'].refs[`input_${v.name}`].classList.remove(
              s['error']
            );
          if (data) {
            v.value = data.data || 'loading···';
            v.alias = data.alias || '';
          } else {
            if (v.point == undefined || v.point == '') {
              v.point = '';
            } else {
              v.point = '非正确点名';
              this.refs['Table'].refs[`input_${v.name}`] &&
                this.refs['Table'].refs[`input_${v.name}`].classList.add(
                  s['error']
                );
            }
          }
        });
        this.setState({
          spinner: false,
          dataSource
        });
        this._getDsValues(ids);
      }
    });
  }
  _getDsValues(ids) {
    if (this.getDsValuesAsync) {
      return;
    }
    this.setState({
      spinner: true
    });
    this.getDsValuesAsync = apiFetch.getRealtimeData(ids).subscribe({
      fail: rs => {
        this.getDsValuesAsync = undefined;
        console.log(rs);
      },
      next: rs => {
        if (rs.error) {
          rs = {
            dsItemList: []
          };
        }
        this.getDsValuesAsync = undefined;

        let { dataSource } = this.state;
        rs.dsItemList.forEach(v => {
          let data = this.dsMap.get(v.dsItemId);
          if (data) {
            data.data = v.data;
          }
        });
        dataSource.forEach((v, i) => {
          let data = this.dsMap.get(v.point);
          let num = (data && data.data) || undefined;
          num =
            isNaN(Number(num)) || Number(num) == 0
              ? num || ''
              : Number(num).toFixed(2);
          v.value = num;
        });
        this.setState({
          spinner: false,
          dataSource
        });
      }
    });
  }
  _getDsHistory(state, props) {
    if (this.getDsHistoryAsync) {
      return;
    }
    const { dataSource, selectedColumns } = state;
    const timeConfig = props.data.options.timeConfig || {};
    const { timeStart, timeEnd, timeFormat } = timeConfig;
    let ids = selectedColumns.map(
      id => dataSource.find(d => d.key == id).point || ''
    );
    this.setState({
      chartSpinner: true
    });
    this.getDsHistoryAsync = apiFetch
      .getHistoryData(ids.filter(v => v != ''), timeStart, timeEnd, timeFormat)
      .subscribe({
        fail: rs => {
          this.getDsHistoryAsync = undefined;
          console.log(rs);
        },
        next: rs => {
          if (rs.error || !rs.list) {
            rs = {
              list: [],
              timeShaft: []
            };
          }
          this.getDsHistoryAsync = undefined;
          this.setState({
            chartSpinner: false,
            historyData: rs
          });
        }
      });
  }
  _doNothing(ev) {
    ev.preventDefault();
  }
  _onGroupSelect(selectedKeys) {
    const { data, updateModule } = this.props;
    this.setState({
      selectedColumns: []
    });
    updateModule(data.setIn(['options', 'activedGroup'], selectedKeys[0]));
  }
  _onAddGroupBtn() {
    this.setState({
      showAddItem: true
    });
  }
  _addGroup(activeId, val, groupData = {}) {
    const { data, updateModule, i18n } = this.props;
    this.setState({
      showAddItem: false
    });
    if (!val || data.options.groups.map(v => v.name).indexOf(val) > -1) {
      Confirm({
        title: i18n.TOOLTIP,
        type: 'info',
        content: i18n.PARAM_GROUP_NAME_BEEN_USED.replace('{num}', val),
        onOk: () => {}
      });
      return;
    } else {
      updateModule(
        data.setIn(['options', 'groups', data.options.groups.length], {
          _id: activeId,
          name: val,
          data: groupData
        })
      );
    }
  }
  _renameGroup(activeId, val) {
    const { data, updateModule } = this.props;
    const activedGroup = activeId || data.options.activedGroup;
    let selectedItem = data.options.groups.find(v => v._id == activedGroup);
    if (val == selectedItem.name) {
      return;
    }
    if (!val || data.options.groups.map(v => v.name).indexOf(val) > -1) {
      Confirm({
        title: i18n.TOOLTIP,
        type: 'info',
        content: i18n.PARAM_GROUP_NAME_BEEN_USED.replace('{num}', val),
        onOk: () => {}
      });
      return;
    } else {
      let index = data.options.groups.findIndex(v => v._id == activedGroup);
      updateModule(
        data.setIn(['options', 'groups', index], selectedItem.set('name', val))
      );
    }
  }
  _removeGroup(activeId) {
    const { data, updateModule, i18n } = this.props;
    const activedGroup = activeId || data.options.activedGroup;
    let selectedItem = data.options.groups.find(v => v._id == activedGroup);
    Confirm({
      title: i18n.TOOLTIP,
      type: 'info',
      content: i18n.SURE_DELETE_PARAM.replace('{num}', selectedItem.name),
      onOk: () => {
        this.setState({
          selectedColumns: []
        });
        if (data.options.groups.length == 1) {
          //必须剩下一个默认的
          let index = data.options.groups.findIndex(v => v._id == activedGroup);
          let newId = ObjectId();
          updateModule(
            data
              .setIn(['options', 'groups', index], {
                _id: newId,
                name: 'Default',
                data: {}
              })
              .setIn(['options', 'activedGroup'], newId)
          );
        } else {
          updateModule(
            data
              .setIn(
                ['options', 'groups'],
                data.options.groups.flatMap(
                  v => (v._id == activedGroup ? [] : v)
                )
              )
              .setIn(['options', 'activedGroup'], data.options.groups[0]._id)
          );
        }
      },
      onCancel: () => {}
    });
  }
  _onColumnSelected(keys) {
    this.setState({
      selectedColumns: keys
    });
  }
  _getColumns() {
    const { i18n } = this.props;
    return [
      {
        title: i18n.PARAMETER_NAME,
        key: 'name',
        width: '20%'
      },
      {
        title: i18n.POINT_VALUE,
        key: 'point',
        width: '20%',
        render: (value, data) => {
          return (
            <input
              className={css('pointInput')}
              ref={`input_${data.name}`}
              data-value={value}
              data-name={data.name}
              onDragOver={this._doNothing}
              onDrop={this._onInputDrop}
              onBlur={this._onInputBlur}
              onFocus={this._onInputFocus}
              onKeyDown={this._onInputKeyDown}
              onClick={e => {
                e.stopPropagation();
              }}
            />
          );
        }
      },
      {
        title: i18n.REAL_TIME_VALUE,
        key: 'value',
        width: '20%'
      },
      {
        title: i18n.TAG,
        key: 'tag',
        width: '20%',
        render: tags => {
          return (
            <ul className={css('tagUl')}>
              {tags.map((tag, i) => <li key={i}>{tag}</li>)}
            </ul>
          );
        }
      },
      {
        title: i18n.ANNOTATION,
        key: 'alias',
        width: '20%'
      },
      {
        title: '图表',
        key: 'icon',
        width: '28px',
        render: tags => {
          return <i className={'ms-Icon ms-Icon--Chart'} />;
        }
      }
    ];
  }
  _onTabelDrop(ev) {
    const { updateModule, data, i18n } = this.props;
    const activedGroup = data.options.activedGroup;
    let dragTagInfo = ev.dataTransfer.getData('dragTagInfo'),
      dragDsInfo = ev.dataTransfer.getData('dragDsInfo'),
      dragInfo = dragTagInfo || dragDsInfo;
    if (dragInfo) {
      let info = JSON.parse(dragInfo);
      let index = data.options.groups.findIndex(v => v._id == activedGroup);
      if (data.options.params.map(v => v.name).indexOf(info.name) > -1) {
        Confirm({
          title: i18n.TOOLTIP,
          type: 'info',
          content: i18n.PARAM_NAME_BEEN_USED.replace('{name}', info.name),
          onOk: () => {}
        });
      } else {
        updateModule(
          data
            .setIn(['options', 'params', data.options.params.length], {
              description: '',
              name: info.name,
              sample: '',
              tags: info.tags
            })
            .setIn(
              ['options', 'groups', index, 'data'],
              data.options.groups[index].data.set(info.name, info.id)
            )
        );
      }
    }
  }
  _onTreeDrop(ev) {
    const {
      updateModule,
      data,
      i18n,
      selectedDataSourceProjectId
    } = this.props;
    const activedGroup = data.options.activedGroup;
    let dragTagGroupInfo = ev.dataTransfer.getData('dragTagGroupInfo');
    if (dragTagGroupInfo) {
      let info = JSON.parse(dragTagGroupInfo);
      this.setState({
        treeSpinner: true
      });
      let asyncArr = [],
       async = $.Deferred();
      const check = ()=>{
        let statusArr = asyncArr.map(v=>v.status);
        if(statusArr.indexOf(0)<0){
          async.resolve(asyncArr);
        }else{
          let txt = (statusArr.filter(v=>v==1).length/statusArr.length*100).toFixed(1)+'%';
          this.setState({
            treeSpinnerLabel:txt 
          });
        }
      }
      const loop = (id,name) => {
        asyncArr.push({
          id: id,
          data: [],
          status: 0,
          name
        });
        apiFetch.getDataSourceList(selectedDataSourceProjectId, id).subscribe({
          fail: rs => {},
          next: rs => {
            if(rs.data && rs.data.length){
              let target = asyncArr.find(v=>v.id==id);
              target.status = 1;
              target.data = rs.data.filter(v=>v.type=='thing');
              let groups = rs.data.filter(v=>v.type!='thing');
              if(groups.length>0){
                groups.forEach(g=>{
                  loop(g._id,`${name}_${g.name}`);
                });
              }else{
                check();
              }
            }else{
              check();
            }
          }
        });
      };
      loop(info._id,info.name);
      async.done((rs)=>{
        this.setState({
          treeSpinner: false,
          treeSpinnerLabel:'0.0%'
        });
        rs.forEach(info=>{
          let groupData = {};
          data.options.params.forEach(param=>{
            let targetName = '';
            let maxNum = 0;
            info.data.forEach(v=>{
              let tagMatchRs = tagMatch(param.tags,v.tag);
              if(tagMatchRs>=maxNum){
                targetName = v.name;
                maxNum = tagMatchRs;
              }
            });
            groupData[param.name] = targetName?`@${selectedDataSourceProjectId}|${targetName}`:'';
          });
          this._addGroup(ObjectId(), info.name,groupData);
        });
          
          
      });
    }
  }
  _onInputDrop(ev) {
    const { updateModule, data } = this.props;
    const activedGroup = data.options.activedGroup;
    let dragTagInfo = ev.dataTransfer.getData('dragTagInfo'),
      dragDsInfo = ev.dataTransfer.getData('dragDsInfo'),
      dragInfo = dragTagInfo || dragDsInfo;
    if (dragInfo) {
      ev.target.classList.remove(s['error']);
      this.setState({
        selectedColumns: []
      });
      let info = JSON.parse(dragInfo);
      let index = data.options.groups.findIndex(v => v._id == activedGroup);
      updateModule(
        data.setIn(
          ['options', 'groups', index, 'data'],
          data.options.groups[index].data.set(ev.target.dataset.name, info.id)
        )
      );
    }
  }
  _onInputBlur(ev) {
    const { updateModule, data } = this.props;
    const activedGroup = data.options.activedGroup;
    let index = data.options.groups.findIndex(v => v._id == activedGroup);
    if (
      data.options.groups[index].data[ev.target.dataset.name] ==
        ev.target.value &&
      !ev.target.classList.contains(s['error'])
    ) {
      return;
    }
    ev.target.classList.remove(s['error']);
    this.setState({
      selectedColumns: []
    });
    updateModule(
      data.setIn(
        ['options', 'groups', index, 'data'],
        data.options.groups[index].data.set(
          ev.target.dataset.name,
          ev.target.value || ''
        )
      )
    );
  }
  _onInputKeyDown(ev) {
    if (ev.key == 'Enter') {
      $(ev.target).blur();
    }
  }
  _onInputFocus(ev) {
    const { updateModule, data } = this.props;
    const activedGroup = data.options.activedGroup;
    let selectedItem = data.options.groups.find(v => v._id == activedGroup);
    if (ev.target.value == '非正确点名') {
      ev.target.classList.add(s['error']);
      ev.target.value = selectedItem.data[ev.target.dataset.name] || '';
    }
  }
  _createChart() {
    const { dataSource, selectedColumns, historyData } = this.state;
    if (selectedColumns.length == 0) {
      return null;
    }
    let series = [],
      dataName = [],
      item = undefined;
    let color = [
        ['#aaaaff1a', '#66ccff', '#aaaaff'],
        ['#69bd761a', '#edff9b', '#69bd76'],
        ['#f4c0651a', '#ff6666', '#f4c065'],
        ['#3366ff1a', '#5da9ff', '#3366ff'],
        ['#4d8ad01a', '#75b4fd', '#4d8ad0'],
        ['#d581fc1a', '#fc84d3', '#d581fc'],
        ['#75b4fd1a', '#65f2fb', '#75b4fd'],
        ['#f4ff5d1a', '#f3df5e', '#f4ff5d'],
        ['#9935cc1a', '#66ccff', '#9935cc']
      ],
      cColor = [];
    historyData.list.forEach((v, index) => {
      let item = this.dsMap.get(v.dsItemId) || {};
      series[index] = {
        name: item.alias || '',
        type: 'line',
        data: v.data,
        areaStyle: {
          normal: {
            color: color[index % 9][0]
          }
        },
        lineStyle: {
          normal: {
            type: 'solid'
          }
        }
      };
      cColor[index] = color[index % 9][2]
      dataName[index] = {
        name: item.alias || '',
        icon: 'roundRect',
        textStyle: {
          color: '#555'
        }
      };
    });
    let option = {
      tooltip: {
        trigger: 'axis'
      },
      color: cColor,
      legend: {
        itemWidth: 9,
        itemHeight: 8,
        left: 'center',
        top: '20',
        data: dataName
      },
      xAxis: [
        {
          type: 'category',
          boundaryGap: false,
          data: historyData.timeShaft,
          axisLabel: {
            formatter: function(value, index) {
              return moment.default(value).format('MM-DD HH:ss');
            }
          },
          axisTick: {
            show: false
          },
          splitLine: {
            show: false
          }
        }
      ],
      yAxis: [
        {
          type: 'value',
          axisTick: {
            show: false
          },
          splitLine: {
            show: false
          }
        }
      ],
      series: series
    };
    return (
      <ReactEcharts
        option={option}
        style={{ height: '100%', width: '100%' }}
        className="react_for_echarts"
      />
    );
  }
  _setChartCondition(conditions) {
    const { updateModule, data } = this.props;
    let timeConfig = Object.assign(
      {},
      data.options.timeConfig || {},
      conditions
    );
    updateModule(data.setIn(['options', 'timeConfig'], timeConfig));
  }
  _showModal() {
    this.refs.ParametricExampleModal.toggleShow(true);
  }
  _showChartConfig() {}
  _updateData(arr) {
    let names = arr.flatMap(v => v.name);
    let newGroups = this.props.data.options.groups.flatMap(group => {
      let newData = {};
      names.forEach(name => {
        if (group.data[name] != undefined) {
          newData[name] = group.data[name];
        }
      });
      return group.set('data', newData);
    });
    this.props.updateModule(
      this.props.data
        .setIn(['options', 'params'], arr)
        .setIn(['options', 'groups'], newGroups)
    );
  }
  _onCheckboxChang(ev, isChecked) {
    const { updateModule, data } = this.props;
    updateModule(data.setIn(['options', 'completing'], isChecked ? 1 : 0));
  }
}

DataSourcePanel.propTypes = {};
var mapDispatchToProps = {
  getTagDict
};

var mapStateToProps = function(state) {
  return {
    tagDict: state.home.tagDict,
    selectedDataSourceProjectId: state.home.selectedDataSourceProjectId
  };
};

export default connect(mapStateToProps, mapDispatchToProps)(DataSourcePanel);
