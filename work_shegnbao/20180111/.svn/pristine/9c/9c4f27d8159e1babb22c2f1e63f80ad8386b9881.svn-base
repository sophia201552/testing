import React from 'react';
import PropTypes from 'prop-types';
import $ from 'jquery';
import * as moment from 'moment';
import { Checkbox } from 'office-ui-fabric-react/lib/Checkbox';
import { Panel, PanelType } from 'office-ui-fabric-react/lib/Panel';
import ReactDataGrid from 'react-data-grid';

import CustomSpinner from '../../../components/CustomSpinner';
import Pagination from '../../../components/Pagination';
import Confirm from '../../../components/Confirm';
import ChartViewModal from './ChartViewModal';
import CheckboxGroup from './CheckboxGroup';
import SearchGroup from './SearchGroup';
import RulePanel from './RulePanel';

import s from './DataMonitoringPanel.css';
const css = (className1, className2 = '') => {
  return className1
    .split(' ')
    .map(v => s[v])
    .concat(className2.split(' '))
    .join(' ')
    .trim();
};
const shouldStop = e => {
  return $(e.target)
    .closest('div')
    .hasClass(s['disabled']);
};

class DataMonitoringPanel extends React.Component {
  constructor(props) {
    super(props);
    this.isNeedAsyncData = true;
    this.couldUpdate = true;
    this.state = {
      //分页数据相关
      current: 1,
      pageSize: 20,
      total: 1,
      //数据相关
      datasource: [],
      updateDatasource: [],
      //筛选条件
      filterCfg: [],
      searchType: 'originalPointName',
      searchMode: 'regex',
      searcValue: '',
      //表格相关
      tableHeight: 350,
      selectedIndexes: [],
      //批量配置相关
      batchConfigShow: false,
      //历史相关
      chartHistoryShow: false,
      chartHistoryNames: [],
      //表格spinner
      tableSpinner: false
    };
    this.baseColumns = [
      {
        key: 'originalPointName',
        name: props.i18n.ORIGINAL_POINT_NAME,
        width: 200,
        resizable: true,
        toolTip: '',
        disabled: true
      },
      {
        key: 'sitePointName',
        name: props.i18n.SITE_POINT_NAME,
        width: 200,
        resizable: true,
        toolTip: '',
        disabled: true
      },
      {
        key: 'pointAnnotation',
        name: props.i18n.POINT_ANNOTATION,
        width: 200,
        resizable: true,
        toolTip: '',
        disabled: true
      },
      {
        key: 'realtimeValue',
        name: props.i18n.REALTIME_VALUE,
        width: 200,
        resizable: true,
        toolTip: '',
        disabled: true
      },
      {
        key: 'realtimeValueUpdateTime',
        name: props.i18n.REALTIME_VALUE_UPDATE_TIME,
        width: 200,
        resizable: true,
        toolTip: ''
      },
      {
        key: 'dtuName',
        name: props.i18n.DTU_NAME,
        width: 200,
        resizable: true,
        toolTip: props.i18n.ANNOTATION_DTU_NAME,
        disabled: true
      },
      {
        key: 'dtuDisplayName',
        name: props.i18n.DTU_DISPLAY_NAME,
        width: 200,
        resizable: true,
        toolTip: props.i18n.ANNOTATION_DTU_DISPLAY_NAME,
        disabled: true
      },
      {
        key: 'exchangerDisplayName',
        name: props.i18n.EXCHANGER_DISPLAY_NAME,
        width: 200,
        resizable: true,
        toolTip: props.i18n.ANNOTATION_EXCHANGER_DISPLAY_NAME,
        disabled: true
      },
      {
        key: 'updateTimePointName',
        name: props.i18n.UPDATE_TIME_POINT_NAME,
        width: 200,
        resizable: true,
        toolTip: '',
        disabled: true
      },
      {
        key: 'tag',
        name: props.i18n.TAG,
        width: 400,
        resizable: true,
        toolTip: '',
        disabled: true
      }
    ];
    this.wrangColumns = [
      {
        key: 'unit',
        name: props.i18n.UNIT,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: ''
      },
      {
        key: 'min',
        name: props.i18n.MIN,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: ''
      },
      {
        key: 'max',
        name: props.i18n.MAX,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: ''
      },
      {
        key: 'continues',
        name: props.i18n.CONTINUES,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: props.i18n.ANNOTATION_CONTINUES
      },
      {
        key: 'condition',
        name: props.i18n.CONDITION,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: props.i18n.ANNOTATION_CONDITION
      },
      // {
      //   key: 'type_en',
      //   name: '设备类型(英文)',
      //   width: 200,
      //   resizable: true,
      //   editable: true,
      //   toolTip: ''
      // },
      // {
      //   key: 'type_zh',
      //   name: '设备类型(中文)',
      //   width: 200,
      //   resizable: true,
      //   editable: true,
      //   toolTip: ''
      // },
      {
        key: 'relation',
        name: props.i18n.RELATION,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: props.i18n.ANNOTATION_RELATION
      },
      {
        key: 'offlineCheckTime',
        name: props.i18n.OFFLINE_CHECK_TIME,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: props.i18n.ANNOTATION_OFFLINE_CHECK_TIME
      },
      {
        key: 'suddenChange',
        name: props.i18n.SUDDEN_CHANGE,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: props.i18n.ANNOTATION_SUDDEN_CHANGE
      },
      {
        key: 'suddenChangeRatio',
        name: props.i18n.SUDDEN_CHANGE_RATIO,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: props.i18n.ANNOTATION_SUDDEN_CHANGE_RATIO
      },
      {
        key: 'oscillationCheck',
        name: props.i18n.OSCILLATION_CHECK,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: props.i18n.ANNOTATION_OSCILLATION_CHECK
      },
      {
        key: 'dataSourceType',
        name: props.i18n.DATA_SOURCE_TYPE,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: props.i18n.ANNOTATION_DATA_SOURCE_TYPE
      },
      {
        key: 'slopeNegativeCheck',
        name: props.i18n.SLOPE_NEGATIVE_CHECK,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: props.i18n.ANNOTATION_SLOPE_NEGATIVE_CHECK
      },
      {
        key: 'annotation',
        name: props.i18n.ANNOTATION,
        width: 200,
        resizable: true,
        editable: true,
        toolTip: ''
      }
    ];
    //表格相关
    this._tableRowGetter = this._tableRowGetter.bind(this);
    this._onTableRowUpdate = this._onTableRowUpdate.bind(this);
    this._onCheckboxGroupChnage = this._onCheckboxGroupChnage.bind(this);
    this._onTableResize = this._onTableResize.bind(this);
    this._onRowsSelected = this._onRowsSelected.bind(this);
    this._onRowsDeselected = this._onRowsDeselected.bind(this);
    //分页相关
    this._onPageChange = this._onPageChange.bind(this);
    this._onChangeValue = this._onChangeValue.bind(this);
    //筛选搜索相关
    this._onFilterCfgChange = this._onFilterCfgChange.bind(this);
    this._onSearchTypeChange = this._onSearchTypeChange.bind(this);
    this._onSearch = this._onSearch.bind(this);
    //toolbar相关
    this._onBatchConfigBtn = this._onBatchConfigBtn.bind(this);
    this._onDeleteRowBtn = this._onDeleteRowBtn.bind(this);
    this._onHistoryBtn = this._onHistoryBtn.bind(this);
    this._onAsyncBtn = this._onAsyncBtn.bind(this);
    this._onSaveChangeBtn = this._onSaveChangeBtn.bind(this);
    this._onRebackChangeBtn = this._onRebackChangeBtn.bind(this);
    this._onFromTag = this._onFromTag.bind(this);
    this._onFromExcel = this._onFromExcel.bind(this);
    this._importFile = this._importFile.bind(this);
    //历史相关

    //批量配置相关
    this._onBatchConfigOK = this._onBatchConfigOK.bind(this);
    this._onBatchConfigCancel = this._onBatchConfigCancel.bind(this);
  }
  componentDidMount() {
    this._onTableResize();
  }
  componentDidUpdate() {
    this._getTableAsync();
  }
  componentWillUnmount() {
    this.couldUpdate = false;
  }
  render() {
    const {
      current,
      pageSize,
      total,
      datasource,
      updateDatasource,
      filterCfg,
      searchType,
      searcValue,
      tableHeight,
      batchConfigShow,
      selectedIndexes,
      chartHistoryShow,
      chartHistoryNames,
      tableSpinner
    } = this.state;
    const { data, updateModule, i18n } = this.props;
    const { columnSelectedKeys } = data.options;
    let columns = this._columnsGetter();
    return (
      <div className={css('dataMonitoringPanel')} ref={'dataMonitoringPanel'}>
        <div className={css('checkGroupWrap')} ref={'checkGroupWrap'}>
          <CheckboxGroup
            title={i18n.BASE_ATTRIBUTE}
            selectedKeys={columnSelectedKeys}
            items={this.baseColumns}
            selectChange={this._onCheckboxGroupChnage}
            onResize={this._onTableResize}
          />
          <CheckboxGroup
            title={i18n.CONFIGURATION_ATTRIBUTE}
            selectedKeys={columnSelectedKeys}
            items={this.wrangColumns}
            selectChange={this._onCheckboxGroupChnage}
            onResize={this._onTableResize}
          />
        </div>
        <div className={css('tableWrap')} ref={'tableWrap'}>
          <div className={css('toolbar clear')} ref={'toolbar'}>
            <div className={css('toolbarL clear')}>
              <div className={css('item')}>
                <Checkbox
                  label={i18n.NOT_CONFIGURED}
                  checked={filterCfg.indexOf('isNoCfg') >= 0}
                  onChange={this._onFilterCfgChange.bind(this, 'isNoCfg')}
                />
              </div>

              <div className={css('item')}>
                <Checkbox
                  label={i18n.CONFIGURED}
                  checked={filterCfg.indexOf('isAllCfg') >= 0}
                  onChange={this._onFilterCfgChange.bind(this, 'isAllCfg')}
                />
              </div>
            </div>
            <div className={css('toolbarC clear')}>
              <div className={css('item')} onClick={this._onBatchConfigBtn}>
                <i className={'ms-Icon ms-Icon--Share'} />
                <span>{i18n.BATCH_CONFIGURATION}</span>
              </div>
              <div
                className={css(
                  `item ${selectedIndexes.length > 0 ? '' : 'disabled'}`
                )}
                onClick={this._onDeleteRowBtn}
              >
                <i className={'ms-Icon ms-Icon--Save'} />
                <span>
                  {i18n.CLEAR_CONFIGURATION}
                  {selectedIndexes.length > 0
                    ? `(${selectedIndexes.length})`
                    : ''}
                </span>
              </div>
              <div
                className={css(
                  `item ${chartHistoryNames.length > 0 ? '' : 'disabled'}`
                )}
                onClick={this._onHistoryBtn}
              >
                <i className={'ms-Icon ms-Icon--Share'} />
                <span>
                  {i18n.HISTORY}
                  {chartHistoryNames.length > 0
                    ? `(${chartHistoryNames.length})`
                    : ''}
                </span>
              </div>
              <div className={css('item')} onClick={this._onAsyncBtn}>
                <i className={'ms-Icon ms-Icon--Download'} />
                <span>{i18n.REFRESH}</span>
              </div>
              <div className={css('item')} onClick={this._onFromTag}>
                <i className={'ms-Icon ms-Icon--Download'} />
                <span>{i18n.FROM_TAG_IMPORT}</span>
              </div>
              <div className={css('item')} onClick={this._onFromExcel}>
                <input
                  ref="excelFileIpt"
                  style={{ display: 'none' }}
                  type="file"
                  onChange={this._importFile}
                />
                <i className={'ms-Icon ms-Icon--Download'} />
                <span>{i18n.FROM_EXCEL}</span>
              </div>
              <div className={css('item disabled')}>
                <span>|</span>
              </div>
              <div
                className={css(
                  `item ${updateDatasource.length > 0 ? '' : 'disabled'}`
                )}
                onClick={this._onSaveChangeBtn}
              >
                <i className={'ms-Icon ms-Icon--Save'} />
                <span>{i18n.SAVE}</span>
              </div>
              <div
                className={css(
                  `item ${updateDatasource.length > 0 ? '' : 'disabled'}`
                )}
                onClick={this._onRebackChangeBtn}
              >
                <i className={'ms-Icon ms-Icon--DisableUpdates'} />
                <span>{i18n.RESET}</span>
              </div>
            </div>
            <div className={css('toolbarR clear')}>
              <SearchGroup
                selectedKey={searchType}
                selectedValue={searcValue}
                onChange={this._onSearchTypeChange}
                onSearch={this._onSearch}
                i18n={i18n}
              />
            </div>
          </div>
          <div className={css('content')}>
            <ReactDataGrid
              rowKey="originalPointName"
              enableCellSelect={true}
              columns={columns}
              rowGetter={this._tableRowGetter}
              rowsCount={datasource.length}
              minHeight={tableHeight}
              minColumnWidth={120}
              onGridRowsUpdated={this._onTableRowUpdate}
              rowHeight={45}
              rowSelection={{
                showCheckbox: true,
                enableShiftSelect: true,
                onRowsSelected: this._onRowsSelected,
                onRowsDeselected: this._onRowsDeselected,
                selectBy: {
                  indexes: selectedIndexes
                }
              }}
            />
            <CustomSpinner
              visible={tableSpinner}
              backgroundColor="rgba(255,255,255,.4)"
            />
          </div>
        </div>
        <div className={css('pageWrap')} ref={'pageWrap'}>
          <Pagination
            current={current}
            pageSize={pageSize}
            total={total}
            onChange={this._onPageChange}
            onChangeValue={this._onChangeValue}
            isShowPageSize={true}
          />
        </div>
        <ChartViewModal
          ids={chartHistoryNames.map(
            name => `@${appConfig.project.id}|${name}`
          )}
          isOpen={chartHistoryShow}
          onCancel={() => {
            this.setState({ chartHistoryShow: false });
          }}
          onDelete={a => {
            let x = a.map(v => v.replace(`@${appConfig.project.id}|`, ''));
            this.setState({
              chartHistoryNames: x
            });
          }}
          i18n={i18n}
        />
        <Panel
          className={s['rulePanel']}
          isOpen={batchConfigShow}
          type={PanelType.smallFluid}
          onDismiss={this._onBatchConfigCancel}
          forceFocusInsideTrap={false}
          ignoreExternalFocusing={true}
          isBlocking={false}
          isLightDismiss={true}
        >
          <RulePanel
            data={data}
            columnNames={this.wrangColumns}
            columnSelectedKeys={columnSelectedKeys}
            onOK={this._onBatchConfigOK}
            onCancel={this._onBatchConfigCancel}
            i18n={i18n}
          />
        </Panel>
      </div>
    );
  }
  _getTableAsync() {
    if (!this.isNeedAsyncData) {
      return;
    }
    const { data } = this.props;
    const { columnSelectedKeys } = data.options;
    const {
      current,
      pageSize,
      filterCfg,
      searchType,
      searcValue,
      searchMode
    } = this.state;
    let fieldsConfigured = [];
    filterCfg.forEach(v => {
      switch (v) {
        case 'isNoCfg':
          columnSelectedKeys.forEach(v => {
            fieldsConfigured.push(`${v}|0`);
          });
          break;
        case 'isAllCfg':
          columnSelectedKeys.forEach(v => {
            fieldsConfigured.push(`${v}|1`);
          });
          break;
      }
    });
    if (filterCfg.length == 0 || filterCfg.length == 2) {
      fieldsConfigured = [];
    }
    let fieldsConfiguredSet = new Set(this.wrangColumns.map(v => v.key));
    fieldsConfigured = fieldsConfigured.filter(v => fieldsConfiguredSet.has(v));
    let query = {
      pageIndex: current,
      pageSize,
      searchKeyName: searchType.split('_')[0],
      searchType: searchMode,
      searchPattern:
        searchMode == 'regex'
          ? searcValue
          : `${searcValue[0]}|${searcValue[1]}`,
      fieldsConfigured: fieldsConfigured.join(','),
      sortKeyName: '',
      sortOrder: 'ASC'
    };
    this.isNeedAsyncData = false;
    let tableSpinner = true;
    apiFetch.dqdConfigsGet(appConfig.project.id, query).subscribe({
      fail: rs => {},
      next: rs => {
        if (!this.couldUpdate) {
          return;
        }
        let newState = {};
        if (rs.data) {
          newState.datasource = rs.data.configs;
          newState.total = rs.data.total;
          newState.selectedIndexes = [];
        }

        newState.tableSpinner = false;
        this.setState(newState);
      }
    });
    this.setState({
      tableSpinner
    });
  }
  _columnsGetter() {
    const { data } = this.props;
    const { columnSelectedKeys } = data.options;
    let columns = this.baseColumns
      .concat(this.wrangColumns)
      .filter(v => columnSelectedKeys.indexOf(v.key) > -1);
    let originalPointNameInedex = columns.findIndex(
      v => v.key == 'originalPointName'
    );
    let temp = Object.assign({}, columns[originalPointNameInedex]);
    temp.formatter = this._pointNameFormatterGetter();
    columns[originalPointNameInedex] = temp;

    let tagInedex = columns.findIndex(v => v.key == 'tag');
    let tempTag = Object.assign({}, columns[tagInedex]);
    tempTag.formatter = this._tagFormatterGetter();
    columns[tagInedex] = tempTag;
    return columns;
  }
  _pointNameFormatterGetter() {
    const _this = this;
    return class OriginalPointName extends React.Component {
      render() {
        const { value } = this.props;
        const { chartHistoryNames } = _this.state;
        return (
          <div className={css('originalPointNameWrap')}>
            {value}
            <div className={css(`btnWrap`)} onClick={this._btnClick.bind(this)}>
              <i
                className={`ms-Icon ms-Icon--${
                  chartHistoryNames.indexOf(value) > -1
                    ? 'Photo2Remove'
                    : 'Photo2Add'
                }`}
              />
            </div>
          </div>
        );
      }
      _btnClick(e) {
        const { chartHistoryNames } = _this.state;
        const { value, i18n } = this.props;
        let isAdd = chartHistoryNames.indexOf(value) < 0;
        let newChartHistoryNames = chartHistoryNames.slice();
        if (isAdd && newChartHistoryNames.length == 10) {
          Confirm({
            title: i18n.TOOLTIP,
            content: i18n.UP_TO_COMPARISONS.replace('{num}', 10),
            type: 'info',
            onOk: () => {},
            onCancel: () => {}
          });
          return;
        } else {
          if (isAdd) {
            newChartHistoryNames.push(value);
          } else {
            newChartHistoryNames = newChartHistoryNames.filter(v => v != value);
          }

          _this.setState({
            chartHistoryNames: newChartHistoryNames
          });
        }
      }
    };
  }
  _tagFormatterGetter() {
    const _this = this;
    return class Tag extends React.Component {
      render() {
        const { value } = this.props;
        return (
          <div className={css('tagUl clear')}>
            {value.map((tag, i) => (
              <div className={css('tagLi')} key={i}>
                {tag}
              </div>
            ))}
          </div>
        );
      }
    };
  }
  _tableRowGetter(i) {
    const { datasource } = this.state;
    let row = datasource[i];
    return Object.assign({}, row, row.rule);
  }
  _onTableRowUpdate({ fromRow, toRow, updated }) {
    let datasource = this.state.datasource.slice(),
      updateDatasource = this.state.updateDatasource.slice();
    updated = this._repairUpdateDatasourceType(updated);
    for (let i = fromRow; i <= toRow; i++) {
      let rowToUpdate = datasource[i];
      let temp = updateDatasource.find(
        v => v.originalPointName == rowToUpdate.originalPointName
      );
      if (temp) {
        Object.assign(temp, updated);
      } else {
        updateDatasource.push(
          Object.assign(
            { originalPointName: rowToUpdate.originalPointName },
            updated
          )
        );
      }

      rowToUpdate.rule = Object.assign({}, rowToUpdate.rule, updated);
    }
    this.setState({ datasource, updateDatasource });
  }
  _repairUpdateDatasourceType(updated) {
    let numberArr = [
      'continues',
      'max',
      'min',
      'offlineCheckTime',
      'oscillationCheck',
      'slopeNegativeCheck',
      'suddenChange',
      'suddenChangeRatio'
    ];
    numberArr.forEach(key => {
      if (Reflect.has(updated, key)) {
        updated[key] = updated[key] == '' ? '' : Number(updated[key]);
      }
    });
    return updated;
  }
  _onPageChange(num) {
    this.isNeedAsyncData = true;
    this.setState({
      current: num
    });
  }
  _onChangeValue(pageSize) {
    this.isNeedAsyncData = true;
    this.setState({
      pageSize
    });
  }
  _onFilterCfgChange(key, ev, isChecked) {
    const { filterCfg } = this.state;
    let newData = filterCfg.concat();
    if (isChecked) {
      newData.push(key);
    } else {
      newData = newData.filter(v => v != key);
    }
    this.isNeedAsyncData = true;
    this.setState({ filterCfg: newData, current: 1 });
  }
  _onSearchTypeChange(key, value, type) {
    // this.setState({
    //   searchMode: type,
    //   searchType: key,
    //   searcValue: value
    // });
  }
  _onSearch(key, value, type) {
    this.isNeedAsyncData = true;
    this.setState({
      searchMode: type,
      searchType: key,
      searcValue: value,
      current: 1
    });
  }
  _onCheckboxGroupChnage(v) {
    const { updateModule, data } = this.props;
    updateModule(data.setIn(['options', 'columnSelectedKeys'], v));
  }
  _onTableResize() {
    let fixedHeight =
      this.refs.pageWrap.offsetHeight + this.refs.checkGroupWrap.offsetHeight;
    let tableHeight =
      $(this.refs.tableWrap)
        .css({
          height: `calc(100% - ${fixedHeight}px)`
        })
        .height() - $(this.refs.toolbar).height();
    this.setState({
      tableHeight
    });
  }
  _onBatchConfigBtn() {
    this.setState({
      batchConfigShow: true
    });
  }
  _onDeleteRowBtn(e) {
    if (shouldStop(e)) {
      return false;
    }
    const { selectedIndexes, datasource, updateDatasource } = this.state;
    const { i18n } = this.props;
    let newDatasource = datasource.slice(),
      newUpdateDatasource = updateDatasource.slice();
    let names = [],
      baseDetectionSettings = {};
    Object.keys(newDatasource[0].rule).forEach(v => {
      baseDetectionSettings[v] = null;
    });
    selectedIndexes.forEach(index => {
      let originalPointName = newDatasource[index].originalPointName;
      names.push(originalPointName);
      newDatasource[index].rule = baseDetectionSettings;
      let temp = newUpdateDatasource.find(v => {
        v.originalPointName == originalPointName;
      });
      if (temp) {
        temp = Object.assign(temp, baseDetectionSettings);
      } else {
        newUpdateDatasource.push(
          Object.assign({ originalPointName }, baseDetectionSettings)
        );
      }
    });
    Confirm({
      title: i18n.TOOLTIP,
      content: `${i18n.IS_CLEAR_CONFIGURATION_ONE}${names
        .slice(0, 3)
        .join(',')}${
        selectedIndexes.length > 3
          ? i18n.IS_CLEAR_CONFIGURATION_TWO
          : i18n.IS_CLEAR_CONFIGURATION_THREE
      }${i18n.IS_CLEAR_CONFIGURATION_FOUR}`,
      type: 'info',
      onOk: () => {
        this.setState({
          datasource: newDatasource,
          selectedIndexes: [],
          updateDatasource: newUpdateDatasource
        });
      },
      onCancel: () => {}
    });
  }
  _onHistoryBtn(e) {
    if (shouldStop(e)) {
      return false;
    }
    const { chartHistoryNames } = this.state;
    this.setState({
      chartHistoryShow: true
    });
  }
  _onAsyncBtn() {
    this.isNeedAsyncData = true;
    this.setState({
      updateDatasource: []
    });
  }
  _onSaveChangeBtn(e) {
    if (shouldStop(e)) {
      return false;
    }
    const { updateDatasource } = this.state;
    let configs = {};
    updateDatasource.forEach(v => {
      configs[v.originalPointName] = v;
      Reflect.deleteProperty(v, 'originalPointName');
    });
    let tableSpinner = true;
    apiFetch.dqdConfigsSave(appConfig.project.id, configs).subscribe({
      fail: rs => {},
      next: rs => {
        tableSpinner = false;
        if (!this.couldUpdate) {
          return;
        }
        if (rs.success) {
          this.setState({ updateDatasource: [], tableSpinner });
        }
      }
    });
    this.setState({
      tableSpinner
    });
  }
  _onRebackChangeBtn(e) {
    if (shouldStop(e)) {
      return false;
    }
    this.isNeedAsyncData = true;
    this.setState({
      updateDatasource: []
    });
  }
  _onRowsSelected = rows => {
    this.setState({
      selectedIndexes: this.state.selectedIndexes.concat(
        rows.map(r => r.rowIdx)
      )
    });
  };

  _onRowsDeselected = rows => {
    let rowIndexes = rows.map(r => r.rowIdx);
    this.setState({
      selectedIndexes: this.state.selectedIndexes.filter(
        i => rowIndexes.indexOf(i) === -1
      )
    });
  };
  _onBatchConfigOK(datas, ruleItems) {
    const { updateModule, data } = this.props;
    const { datasource } = this.state;
    let newDatasource = datasource.slice();
    let oldName = newDatasource.map(v => v.originalPointName);
    datas.forEach(v => {
      let index = oldName.indexOf(v.originalPointName) >= 0;
      // if (index) {
      //   newDatasource[index] = v;
      // } else {
      //   newDatasource.push(v);
      // }
    });
    this.setState({ batchConfigShow: false, datasource: newDatasource });
    updateModule(data.setIn(['options', 'ruleItems'], ruleItems));
  }
  _onBatchConfigCancel() {
    this.setState({ batchConfigShow: false });
  }
  _onFromTag() {
    const { data, i18n } = this.props;
    const { datasource, updateDatasource } = this.state;
    if (this.state.tableSpinner) {
      return;
    }
    Confirm({
      title: i18n.ENTER_MATCH_DEGREE,
      type: 'info',
      value: '0.7',
      onOk: v => {
        if (v.trim() == '' || Number(v) < 0 || Number(v) > 1) {
          Confirm({
            title: i18n.WARNING,
            type: 'warning',
            content: i18n.EMPTY_MATCH_DEGREE,
            onOk: () => {}
          });
          return;
        }
        let query = {
          pointname: datasource.map(v => v.originalPointName),
          pointtag: datasource.map(v => v.tag),
          pointvalue: datasource.map(v => v.realtimeValue),
          ratioline: Number(v)
        };
        let tableSpinner = true;
        apiFetch.dataAttributebyTagInfo(query).subscribe({
          fail: rs => {},
          next: rs => {
            if (!this.couldUpdate) {
              return;
            }
            let newState = {};
            let newUpdateDatasource = updateDatasource.slice(),
              newDatasource = datasource.slice();
            Object.keys(rs).forEach(name => {
              let rule = rs[name];
              Reflect.deleteProperty(rule, 'tags');
              let temp = newUpdateDatasource.find(
                  v => v.originalPointName == name
                ),
                temp2 = newDatasource.find(v => v.originalPointName == name);
              if (temp) {
                Object.assign(temp, rule);
              } else {
                newUpdateDatasource.push(
                  Object.assign({ originalPointName: name }, rule)
                );
              }

              Object.assign(temp2, {
                rule: rule
              });
            });

            newState.updateDatasource = newUpdateDatasource;
            newState.datasource = newDatasource;
            newState.tableSpinner = false;
            this.setState(newState);
          }
        });
        this.setState({
          tableSpinner
        });
        return true;
      },
      onCancel: () => {},
      isShowInput: true
    });
  }
  _onFromExcel() {
    this.refs.excelFileIpt.click();
  }
  _importFile(e) {
    const { i18n } = this.props;
    let file = e.target.files[0];
    let types = [
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    ];
    if (types.indexOf(file.type) < 0) {
      Confirm({
        title: i18n.WARNING,
        type: 'warning',
        content: i18n.UNSUPPORTED_FILE_FORMAT,
        onOk: () => {}
      });
      return;
    }
    let formData = new FormData();
    formData.append('file', e.target.files[0]);
    apiFetch
      .readDataMonitoringExcel(appConfig.project.id, formData)
      .subscribe(resp => {
        if (resp.status === 'OK') {
          this._onAsyncBtn();
        }
      });
  }
}
export default DataMonitoringPanel;
